---
title: Gateway Forwarder
description: Forward Discord Gateway events to your application as webhook-style events
icon: Forward
---

# Gateway Forwarder

The Gateway Forwarder plugin allows you to receive Discord Gateway events through webhook-style HTTP requests instead of maintaining a WebSocket connection. This is particularly useful for serverless environments or when you want to process Gateway events through your existing HTTP infrastructure.

## Architecture Overview

The Gateway Forwarder setup uses a two-part architecture that separates the WebSocket connection handling from your main bot logic. At its core, you'll run two separate Carbon instances that work together to provide a seamless experience.

The first part is a lightweight Gateway Forwarder instance that runs in a traditional, long-running environment like a server or container. This instance's sole responsibility is maintaining the WebSocket connection to Discord and forwarding events. It doesn't need any commands, listeners, or other bot logic - just the Gateway Forwarder plugin. Since it only forwards events outward and doesn't need to receive incoming requests, you don't even need to set up an HTTP server or provide a Carbon adapter. By keeping this instance focused on a single task, you can run it on minimal infrastructure while ensuring a stable connection to Discord's Gateway.

The second part is your main application instance, which contains all your actual bot logic, commands, and event handling. This instance can run anywhere, including serverless environments like AWS Lambda or Vercel, because it doesn't need to maintain any persistent connections. Instead, it receives Gateway events as regular HTTP webhooks, allowing it to scale independently and process events through your existing HTTP infrastructure.

This separation of concerns brings several advantages to your bot's architecture. You can run your main bot logic in serverless environments that typically don't support WebSocket connections, scale your event processing independently of the Gateway connection, and handle all events through your familiar HTTP infrastructure. Most importantly, you can optimize costs by running minimal infrastructure for the WebSocket connection while scaling your main application based on actual usage.

## How It Works

The Gateway Forwarder plugin maintains a WebSocket connection to Discord's Gateway and forwards all events to your specified HTTP endpoint. Each event is signed using Ed25519, similar to Discord's webhook signature system, allowing you to verify that the events are genuine.

## Setting Up Keys

Before using the Gateway Forwarder, you'll need to generate an Ed25519 key pair. Run these commands in your terminal:

```bash title="Terminal"
# Generate key pair and store in variables
KEYPAIR=$(openssl genpkey -algorithm ED25519)
PUBKEY=$(echo "$KEYPAIR" | openssl pkey -pubout)

# Extract raw public key bytes (last 32 bytes) and convert to hex
RAW_PUBKEY=$(echo "$PUBKEY" | grep -v -- "-----" | tr -d '\n' | base64 -d | tail -c 32 | xxd -p -c 64)

# Add public key to .env
echo "FORWARDER_PUBLIC_KEY=\"$RAW_PUBKEY\"" >> .env

# Add private key with escaped newlines to .env
echo -n "FORWARDER_PRIVATE_KEY=\"" >> .env
echo "$KEYPAIR" | awk '{printf "%s\\n", $0}' >> .env
echo "\"" >> .env
```

This will append two environment variables to your `.env` file:
- `FORWARDER_PRIVATE_KEY`: The private key used by the forwarder to sign events
- `FORWARDER_PUBLIC_KEY`: The public key used by your application to verify events

## Forwarder Setup

Create a new application that will run the Gateway Forwarder plugin:

```typescript title="src/index.ts"
import "dotenv/config"
import { Client } from "@buape/carbon"
import { createServer } from "@buape/carbon/adapters/node"
import {
  GatewayForwarderPlugin,
  GatewayIntentBits
} from "@buape/carbon/gateway-forwarder"

const client = new Client(
  {
    baseUrl: process.env.BASE_URL,
    deploySecret: process.env.DEPLOY_SECRET,
    clientId: process.env.DISCORD_CLIENT_ID,
    publicKey: process.env.DISCORD_PUBLIC_KEY,
    token: process.env.DISCORD_BOT_TOKEN
  },
  {},
  [
    new GatewayForwarderPlugin({
      intents: GatewayIntentBits.Guilds | 
               GatewayIntentBits.GuildMessages | 
               GatewayIntentBits.MessageContent,
      webhookUrl: `${process.env.BASE_URL}/events`,
      privateKey: process.env.FORWARDER_PRIVATE_KEY
    })
  ]
)

console.log(
  `Gateway forwarder initialized and ready to forward events to ${process.env.BASE_URL}/events`
)
```

## Receiving Events

In your main application, configure it to accept the forwarded events by adding the forwarder's public key:

```typescript title="src/index.ts"
import { Client } from "@buape/carbon"

const client = new Client({
  baseUrl: process.env.BASE_URL,
  deploySecret: process.env.DEPLOY_SECRET,
  clientId: process.env.DISCORD_CLIENT_ID,
  publicKey: [
    process.env.DISCORD_PUBLIC_KEY,    // Discord's public key
    process.env.FORWARDER_PUBLIC_KEY   // Forwarder's public key
  ],
  token: process.env.DISCORD_BOT_TOKEN
})
```

The events will be delivered to your `/events` endpoint with the following headers:
- `X-Signature-Ed25519`: The event signature
- `X-Signature-Timestamp`: The timestamp used in the signature
- `Content-Type`: `application/json`

The event payload will be formatted as a webhook event:

```typescript
interface WebhookEvent {
  type: number // Always 0 for Gateway events
  event: {
    type: string    // The Gateway event type (e.g., "MESSAGE_CREATE")
    data: unknown   // The event data
  }
}
```

## Security Considerations

1. Keep your private key secure and never commit it to version control
2. Use environment variables to store both public and private keys
3. Always verify the signature of incoming events
4. Use HTTPS for your webhook endpoint

## Best Practices

1. **Error Handling**: Implement proper error handling for failed event deliveries
2. **Retry Logic**: Consider implementing retry logic in case your endpoint is temporarily unavailable
3. **Monitoring**: Monitor the forwarder's connection status and event delivery success rate
4. **Scaling**: Run the forwarder separately from your main application for better scalability

## Environment Variables

Make sure to set these environment variables:

```bash title=".env"
# Standard Discord configuration
BASE_URL="your-base-url"
DEPLOY_SECRET="your-deploy-secret"
DISCORD_CLIENT_ID="your-client-id"
DISCORD_PUBLIC_KEY="discord-public-key"
DISCORD_BOT_TOKEN="your-bot-token"

# Gateway Forwarder configuration
FORWARDER_PUBLIC_KEY="generated-public-key"
FORWARDER_PRIVATE_KEY="generated-private-key"
```

## Quick Start with Railway

You can quickly deploy a Gateway Forwarder using Railway and the `create-carbon` CLI. Here's how:

1. Create a new forwarder project:
```bash
pnpm create carbon@latest
```

2. When prompted:
   - Enter a project name
   - Select "Gateway Forwarder" as the runtime
   - Choose to install dependencies

3. Generate your Ed25519 key pair using the commands in the generated README.md file.

4. Create a new project on [Railway](https://railway.app):
   - Click "New Project"
   - Choose "Deploy from GitHub"
   - Select your forwarder repository

5. Add your environment variables in Railway:
   - `BASE_URL`: Your Railway deployment URL (e.g., https://your-app.railway.app)
   - `DEPLOY_SECRET`: A random string for securing deployments
   - `DISCORD_CLIENT_ID`: Your Discord application ID
   - `DISCORD_PUBLIC_KEY`: Your Discord application public key
   - `DISCORD_BOT_TOKEN`: Your Discord bot token
   - `FORWARDER_PRIVATE_KEY`: The private key generated in step 3

6. Configure the start command in Railway:
   ```bash
   pnpm build && pnpm start
   ```

Your forwarder will now be running on Railway, maintaining a WebSocket connection to Discord's Gateway and forwarding events to your specified endpoint. The minimal setup ensures efficient resource usage while providing reliable event forwarding.

Remember to:
1. Keep your private key secure and never commit it to version control
2. Use the generated public key in your main application's configuration
3. Monitor your forwarder's logs in Railway for any connection issues
4. Consider setting up health checks to ensure the forwarder stays running


